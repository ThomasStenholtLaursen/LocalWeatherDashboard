//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class MetWeatherClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "/weatherapi/locationforecast/2.0";
    }

    /**
     * @return OK
     */
    changelog(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/changelog";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/rss+xml"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangelog(_response);
        });
    }

    protected processChangelog(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param altitude (optional) Whole meters above sea level
     * @param lat Latitude
     * @param lon Longitude
     * @return Success
     */
    classic(altitude: number | null | undefined, lat: number, lon: number): Promise<string> {
        let url_ = this.baseUrl + "/classic?";
        if (altitude !== undefined && altitude !== null)
            url_ += "altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === undefined || lat === null)
            throw new Error("The parameter 'lat' must be defined and cannot be null.");
        else
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === undefined || lon === null)
            throw new Error("The parameter 'lon' must be defined and cannot be null.");
        else
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/xml"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassic(_response);
        });
    }

    protected processClassic(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param altitude (optional) Whole meters above sea level
     * @param lat Latitude
     * @param lon Longitude
     * @param format format code (file extension)
     * @return Success
     */
    anonymous(altitude: number | null | undefined, lat: number, lon: number, format: Format): Promise<string> {
        let url_ = this.baseUrl + "/classic.{format}?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (altitude !== undefined && altitude !== null)
            url_ += "altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === undefined || lat === null)
            throw new Error("The parameter 'lat' must be defined and cannot be null.");
        else
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === undefined || lon === null)
            throw new Error("The parameter 'lon' must be defined and cannot be null.");
        else
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/xml"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnonymous(_response);
        });
    }

    protected processAnonymous(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param altitude (optional) Whole meters above sea level
     * @param lat Latitude
     * @param lon Longitude
     * @return Success
     */
    compact(altitude: number | null | undefined, lat: number, lon: number): Promise<METJSONForecast> {
        let url_ = this.baseUrl + "/compact?";
        if (altitude !== undefined && altitude !== null)
            url_ += "altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === undefined || lat === null)
            throw new Error("The parameter 'lat' must be defined and cannot be null.");
        else
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === undefined || lon === null)
            throw new Error("The parameter 'lon' must be defined and cannot be null.");
        else
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json;charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompact(_response);
        });
    }

    protected processCompact(response: Response): Promise<METJSONForecast> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = METJSONForecast.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<METJSONForecast>(null as any);
    }

    /**
     * @param altitude (optional) Whole meters above sea level
     * @param lat Latitude
     * @param lon Longitude
     * @param format format code (file extension)
     * @return Success
     */
    anonymous2(altitude: number | null | undefined, lat: number, lon: number, format: Format2): Promise<METJSONForecast> {
        let url_ = this.baseUrl + "/compact.{format}?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (altitude !== undefined && altitude !== null)
            url_ += "altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === undefined || lat === null)
            throw new Error("The parameter 'lat' must be defined and cannot be null.");
        else
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === undefined || lon === null)
            throw new Error("The parameter 'lon' must be defined and cannot be null.");
        else
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json;charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnonymous2(_response);
        });
    }

    protected processAnonymous2(response: Response): Promise<METJSONForecast> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = METJSONForecast.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<METJSONForecast>(null as any);
    }

    /**
     * @param altitude (optional) Whole meters above sea level
     * @param lat Latitude
     * @param lon Longitude
     * @return Success
     */
    complete(altitude: number | null | undefined, lat: number, lon: number): Promise<METJSONForecast> {
        let url_ = this.baseUrl + "/complete?";
        if (altitude !== undefined && altitude !== null)
            url_ += "altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === undefined || lat === null)
            throw new Error("The parameter 'lat' must be defined and cannot be null.");
        else
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === undefined || lon === null)
            throw new Error("The parameter 'lon' must be defined and cannot be null.");
        else
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json;charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComplete(_response);
        });
    }

    protected processComplete(response: Response): Promise<METJSONForecast> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = METJSONForecast.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<METJSONForecast>(null as any);
    }

    /**
     * @param altitude (optional) Whole meters above sea level
     * @param lat Latitude
     * @param lon Longitude
     * @param format format code (file extension)
     * @return Success
     */
    anonymous3(altitude: number | null | undefined, lat: number, lon: number, format: Format3): Promise<METJSONForecast> {
        let url_ = this.baseUrl + "/complete.{format}?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (altitude !== undefined && altitude !== null)
            url_ += "altitude=" + encodeURIComponent("" + altitude) + "&";
        if (lat === undefined || lat === null)
            throw new Error("The parameter 'lat' must be defined and cannot be null.");
        else
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === undefined || lon === null)
            throw new Error("The parameter 'lon' must be defined and cannot be null.");
        else
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json;charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnonymous3(_response);
        });
    }

    protected processAnonymous3(response: Response): Promise<METJSONForecast> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = METJSONForecast.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<METJSONForecast>(null as any);
    }

    /**
     * @return OK
     */
    healthz(): Promise<void> {
        let url_ = this.baseUrl + "/healthz";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealthz(_response);
        });
    }

    protected processHealthz(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    schema(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/schema";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/xml"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchema(_response);
        });
    }

    protected processSchema(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    status(): Promise<string> {
        let url_ = this.baseUrl + "/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json;charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param format format code (file extension)
     * @return Success
     */
    anonymous4(format: Format4): Promise<string> {
        let url_ = this.baseUrl + "/status.{format}";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json;charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnonymous4(_response);
        });
    }

    protected processAnonymous4(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("204 No Content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("400 Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("401 Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("403 Forbidden", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("404 Not Found", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("422 Unprocessable Entity", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("429 Too Many Requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("500 Internal Server Error", status, _responseText, _headers);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            return throwException("502 Bad Gateway", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("503 Service Unavailable", status, _responseText, _headers);
            });
        } else if (status === 504) {
            return response.text().then((_responseText) => {
            return throwException("504 Gateway Timeout", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class Forecast implements IForecast {
    meta!: Meta;
    timeseries!: ForecastTimeStep[];

    constructor(data?: IForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.meta = new Meta();
            this.timeseries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.meta = _data["meta"] ? Meta.fromJS(_data["meta"]) : new Meta();
            if (Array.isArray(_data["timeseries"])) {
                this.timeseries = [] as any;
                for (let item of _data["timeseries"])
                    this.timeseries!.push(ForecastTimeStep.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Forecast {
        data = typeof data === 'object' ? data : {};
        let result = new Forecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        if (Array.isArray(this.timeseries)) {
            data["timeseries"] = [];
            for (let item of this.timeseries)
                data["timeseries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IForecast {
    meta: Meta;
    timeseries: ForecastTimeStep[];
}

/** Summary of weather conditions. */
export class ForecastSummary implements IForecastSummary {
    symbol_code!: WeatherSymbol;

    constructor(data?: IForecastSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol_code = _data["symbol_code"];
        }
    }

    static fromJS(data: any): ForecastSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol_code"] = this.symbol_code;
        return data;
    }
}

/** Summary of weather conditions. */
export interface IForecastSummary {
    symbol_code: WeatherSymbol;
}

/** Weather parameters valid for a specific point in time. */
export class ForecastTimeInstant implements IForecastTimeInstant {
    /** Air pressure at sea level */
    air_pressure_at_sea_level?: number | undefined;
    /** Air temperature */
    air_temperature?: number | undefined;
    /** Amount of sky covered by clouds. */
    cloud_area_fraction?: number | undefined;
    /** Amount of sky covered by clouds at high elevation. */
    cloud_area_fraction_high?: number | undefined;
    /** Amount of sky covered by clouds at low elevation. */
    cloud_area_fraction_low?: number | undefined;
    /** Amount of sky covered by clouds at medium elevation. */
    cloud_area_fraction_medium?: number | undefined;
    /** Dew point temperature at sea level */
    dew_point_temperature?: number | undefined;
    /** Amount of area covered by fog. */
    fog_area_fraction?: number | undefined;
    /** Amount of humidity in the air. */
    relative_humidity?: number | undefined;
    /** The direction wind is coming from, in degrees clockwise from North */
    wind_from_direction?: number | undefined;
    /** Speed of wind */
    wind_speed?: number | undefined;
    /** Speed of wind gust */
    wind_speed_of_gust?: number | undefined;

    constructor(data?: IForecastTimeInstant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.air_pressure_at_sea_level = _data["air_pressure_at_sea_level"];
            this.air_temperature = _data["air_temperature"];
            this.cloud_area_fraction = _data["cloud_area_fraction"];
            this.cloud_area_fraction_high = _data["cloud_area_fraction_high"];
            this.cloud_area_fraction_low = _data["cloud_area_fraction_low"];
            this.cloud_area_fraction_medium = _data["cloud_area_fraction_medium"];
            this.dew_point_temperature = _data["dew_point_temperature"];
            this.fog_area_fraction = _data["fog_area_fraction"];
            this.relative_humidity = _data["relative_humidity"];
            this.wind_from_direction = _data["wind_from_direction"];
            this.wind_speed = _data["wind_speed"];
            this.wind_speed_of_gust = _data["wind_speed_of_gust"];
        }
    }

    static fromJS(data: any): ForecastTimeInstant {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastTimeInstant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["air_pressure_at_sea_level"] = this.air_pressure_at_sea_level;
        data["air_temperature"] = this.air_temperature;
        data["cloud_area_fraction"] = this.cloud_area_fraction;
        data["cloud_area_fraction_high"] = this.cloud_area_fraction_high;
        data["cloud_area_fraction_low"] = this.cloud_area_fraction_low;
        data["cloud_area_fraction_medium"] = this.cloud_area_fraction_medium;
        data["dew_point_temperature"] = this.dew_point_temperature;
        data["fog_area_fraction"] = this.fog_area_fraction;
        data["relative_humidity"] = this.relative_humidity;
        data["wind_from_direction"] = this.wind_from_direction;
        data["wind_speed"] = this.wind_speed;
        data["wind_speed_of_gust"] = this.wind_speed_of_gust;
        return data;
    }
}

/** Weather parameters valid for a specific point in time. */
export interface IForecastTimeInstant {
    /** Air pressure at sea level */
    air_pressure_at_sea_level?: number | undefined;
    /** Air temperature */
    air_temperature?: number | undefined;
    /** Amount of sky covered by clouds. */
    cloud_area_fraction?: number | undefined;
    /** Amount of sky covered by clouds at high elevation. */
    cloud_area_fraction_high?: number | undefined;
    /** Amount of sky covered by clouds at low elevation. */
    cloud_area_fraction_low?: number | undefined;
    /** Amount of sky covered by clouds at medium elevation. */
    cloud_area_fraction_medium?: number | undefined;
    /** Dew point temperature at sea level */
    dew_point_temperature?: number | undefined;
    /** Amount of area covered by fog. */
    fog_area_fraction?: number | undefined;
    /** Amount of humidity in the air. */
    relative_humidity?: number | undefined;
    /** The direction wind is coming from, in degrees clockwise from North */
    wind_from_direction?: number | undefined;
    /** Speed of wind */
    wind_speed?: number | undefined;
    /** Speed of wind gust */
    wind_speed_of_gust?: number | undefined;
}

/** Weather parameters valid for a specified time period. */
export class ForecastTimePeriod implements IForecastTimePeriod {
    /** Maximum air temperature in period */
    air_temperature_max?: number | undefined;
    /** Minimum air temperature in period */
    air_temperature_min?: number | undefined;
    /** Best estimate for amount of precipitation for this period */
    precipitation_amount?: number | undefined;
    /** Maximum amount of precipitation for this period */
    precipitation_amount_max?: number | undefined;
    /** Minimum amount of precipitation for this period */
    precipitation_amount_min?: number | undefined;
    /** Probability of any precipitation coming for this period */
    probability_of_precipitation?: number | undefined;
    /** Probability of any thunder coming for this period */
    probability_of_thunder?: number | undefined;
    /** Maximum ultraviolet index if sky is clear */
    ultraviolet_index_clear_sky_max?: number | undefined;

    constructor(data?: IForecastTimePeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.air_temperature_max = _data["air_temperature_max"];
            this.air_temperature_min = _data["air_temperature_min"];
            this.precipitation_amount = _data["precipitation_amount"];
            this.precipitation_amount_max = _data["precipitation_amount_max"];
            this.precipitation_amount_min = _data["precipitation_amount_min"];
            this.probability_of_precipitation = _data["probability_of_precipitation"];
            this.probability_of_thunder = _data["probability_of_thunder"];
            this.ultraviolet_index_clear_sky_max = _data["ultraviolet_index_clear_sky_max"];
        }
    }

    static fromJS(data: any): ForecastTimePeriod {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastTimePeriod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["air_temperature_max"] = this.air_temperature_max;
        data["air_temperature_min"] = this.air_temperature_min;
        data["precipitation_amount"] = this.precipitation_amount;
        data["precipitation_amount_max"] = this.precipitation_amount_max;
        data["precipitation_amount_min"] = this.precipitation_amount_min;
        data["probability_of_precipitation"] = this.probability_of_precipitation;
        data["probability_of_thunder"] = this.probability_of_thunder;
        data["ultraviolet_index_clear_sky_max"] = this.ultraviolet_index_clear_sky_max;
        return data;
    }
}

/** Weather parameters valid for a specified time period. */
export interface IForecastTimePeriod {
    /** Maximum air temperature in period */
    air_temperature_max?: number | undefined;
    /** Minimum air temperature in period */
    air_temperature_min?: number | undefined;
    /** Best estimate for amount of precipitation for this period */
    precipitation_amount?: number | undefined;
    /** Maximum amount of precipitation for this period */
    precipitation_amount_max?: number | undefined;
    /** Minimum amount of precipitation for this period */
    precipitation_amount_min?: number | undefined;
    /** Probability of any precipitation coming for this period */
    probability_of_precipitation?: number | undefined;
    /** Probability of any thunder coming for this period */
    probability_of_thunder?: number | undefined;
    /** Maximum ultraviolet index if sky is clear */
    ultraviolet_index_clear_sky_max?: number | undefined;
}

export class ForecastTimeStep implements IForecastTimeStep {
    /** Forecast for a specific time */
    data!: Data;
    /** The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601) */
    time!: string;

    constructor(data?: IForecastTimeStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new Data();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Data.fromJS(_data["data"]) : new Data();
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): ForecastTimeStep {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastTimeStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["time"] = this.time;
        return data;
    }
}

export interface IForecastTimeStep {
    /** Forecast for a specific time */
    data: Data;
    /** The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601) */
    time: string;
}

export class ForecastUnits implements IForecastUnits {
    air_pressure_at_sea_level?: string | undefined;
    air_temperature?: string | undefined;
    air_temperature_max?: string | undefined;
    air_temperature_min?: string | undefined;
    cloud_area_fraction?: string | undefined;
    cloud_area_fraction_high?: string | undefined;
    cloud_area_fraction_low?: string | undefined;
    cloud_area_fraction_medium?: string | undefined;
    dew_point_temperature?: string | undefined;
    fog_area_fraction?: string | undefined;
    precipitation_amount?: string | undefined;
    precipitation_amount_max?: string | undefined;
    precipitation_amount_min?: string | undefined;
    probability_of_precipitation?: string | undefined;
    probability_of_thunder?: string | undefined;
    relative_humidity?: string | undefined;
    ultraviolet_index_clear_sky_max?: string | undefined;
    wind_from_direction?: string | undefined;
    wind_speed?: string | undefined;
    wind_speed_of_gust?: string | undefined;

    constructor(data?: IForecastUnits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.air_pressure_at_sea_level = _data["air_pressure_at_sea_level"];
            this.air_temperature = _data["air_temperature"];
            this.air_temperature_max = _data["air_temperature_max"];
            this.air_temperature_min = _data["air_temperature_min"];
            this.cloud_area_fraction = _data["cloud_area_fraction"];
            this.cloud_area_fraction_high = _data["cloud_area_fraction_high"];
            this.cloud_area_fraction_low = _data["cloud_area_fraction_low"];
            this.cloud_area_fraction_medium = _data["cloud_area_fraction_medium"];
            this.dew_point_temperature = _data["dew_point_temperature"];
            this.fog_area_fraction = _data["fog_area_fraction"];
            this.precipitation_amount = _data["precipitation_amount"];
            this.precipitation_amount_max = _data["precipitation_amount_max"];
            this.precipitation_amount_min = _data["precipitation_amount_min"];
            this.probability_of_precipitation = _data["probability_of_precipitation"];
            this.probability_of_thunder = _data["probability_of_thunder"];
            this.relative_humidity = _data["relative_humidity"];
            this.ultraviolet_index_clear_sky_max = _data["ultraviolet_index_clear_sky_max"];
            this.wind_from_direction = _data["wind_from_direction"];
            this.wind_speed = _data["wind_speed"];
            this.wind_speed_of_gust = _data["wind_speed_of_gust"];
        }
    }

    static fromJS(data: any): ForecastUnits {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastUnits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["air_pressure_at_sea_level"] = this.air_pressure_at_sea_level;
        data["air_temperature"] = this.air_temperature;
        data["air_temperature_max"] = this.air_temperature_max;
        data["air_temperature_min"] = this.air_temperature_min;
        data["cloud_area_fraction"] = this.cloud_area_fraction;
        data["cloud_area_fraction_high"] = this.cloud_area_fraction_high;
        data["cloud_area_fraction_low"] = this.cloud_area_fraction_low;
        data["cloud_area_fraction_medium"] = this.cloud_area_fraction_medium;
        data["dew_point_temperature"] = this.dew_point_temperature;
        data["fog_area_fraction"] = this.fog_area_fraction;
        data["precipitation_amount"] = this.precipitation_amount;
        data["precipitation_amount_max"] = this.precipitation_amount_max;
        data["precipitation_amount_min"] = this.precipitation_amount_min;
        data["probability_of_precipitation"] = this.probability_of_precipitation;
        data["probability_of_thunder"] = this.probability_of_thunder;
        data["relative_humidity"] = this.relative_humidity;
        data["ultraviolet_index_clear_sky_max"] = this.ultraviolet_index_clear_sky_max;
        data["wind_from_direction"] = this.wind_from_direction;
        data["wind_speed"] = this.wind_speed;
        data["wind_speed_of_gust"] = this.wind_speed_of_gust;
        return data;
    }
}

export interface IForecastUnits {
    air_pressure_at_sea_level?: string | undefined;
    air_temperature?: string | undefined;
    air_temperature_max?: string | undefined;
    air_temperature_min?: string | undefined;
    cloud_area_fraction?: string | undefined;
    cloud_area_fraction_high?: string | undefined;
    cloud_area_fraction_low?: string | undefined;
    cloud_area_fraction_medium?: string | undefined;
    dew_point_temperature?: string | undefined;
    fog_area_fraction?: string | undefined;
    precipitation_amount?: string | undefined;
    precipitation_amount_max?: string | undefined;
    precipitation_amount_min?: string | undefined;
    probability_of_precipitation?: string | undefined;
    probability_of_thunder?: string | undefined;
    relative_humidity?: string | undefined;
    ultraviolet_index_clear_sky_max?: string | undefined;
    wind_from_direction?: string | undefined;
    wind_speed?: string | undefined;
    wind_speed_of_gust?: string | undefined;
}

export class METJSONForecast implements IMETJSONForecast {
    geometry!: PointGeometry;
    properties!: Forecast;
    type!: METJSONForecastType;

    constructor(data?: IMETJSONForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.geometry = new PointGeometry();
            this.properties = new Forecast();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.geometry = _data["geometry"] ? PointGeometry.fromJS(_data["geometry"]) : new PointGeometry();
            this.properties = _data["properties"] ? Forecast.fromJS(_data["properties"]) : new Forecast();
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): METJSONForecast {
        data = typeof data === 'object' ? data : {};
        let result = new METJSONForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>undefined;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IMETJSONForecast {
    geometry: PointGeometry;
    properties: Forecast;
    type: METJSONForecastType;
}

export class PointGeometry implements IPointGeometry {
    /** [longitude, latitude, altitude]. All numbers in decimal. */
    coordinates!: number[];
    type!: PointGeometryType;

    constructor(data?: IPointGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.coordinates = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["coordinates"])) {
                this.coordinates = [] as any;
                for (let item of _data["coordinates"])
                    this.coordinates!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PointGeometry {
        data = typeof data === 'object' ? data : {};
        let result = new PointGeometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

export interface IPointGeometry {
    /** [longitude, latitude, altitude]. All numbers in decimal. */
    coordinates: number[];
    type: PointGeometryType;
}

/** A identifier that sums up the weather condition for this time period, see documentation. */
export enum WeatherSymbol {
    Clearsky_day = "clearsky_day",
    Clearsky_night = "clearsky_night",
    Clearsky_polartwilight = "clearsky_polartwilight",
    Fair_day = "fair_day",
    Fair_night = "fair_night",
    Fair_polartwilight = "fair_polartwilight",
    Lightssnowshowersandthunder_day = "lightssnowshowersandthunder_day",
    Lightssnowshowersandthunder_night = "lightssnowshowersandthunder_night",
    Lightssnowshowersandthunder_polartwilight = "lightssnowshowersandthunder_polartwilight",
    Lightsnowshowers_day = "lightsnowshowers_day",
    Lightsnowshowers_night = "lightsnowshowers_night",
    Lightsnowshowers_polartwilight = "lightsnowshowers_polartwilight",
    Heavyrainandthunder = "heavyrainandthunder",
    Heavysnowandthunder = "heavysnowandthunder",
    Rainandthunder = "rainandthunder",
    Heavysleetshowersandthunder_day = "heavysleetshowersandthunder_day",
    Heavysleetshowersandthunder_night = "heavysleetshowersandthunder_night",
    Heavysleetshowersandthunder_polartwilight = "heavysleetshowersandthunder_polartwilight",
    Heavysnow = "heavysnow",
    Heavyrainshowers_day = "heavyrainshowers_day",
    Heavyrainshowers_night = "heavyrainshowers_night",
    Heavyrainshowers_polartwilight = "heavyrainshowers_polartwilight",
    Lightsleet = "lightsleet",
    Heavyrain = "heavyrain",
    Lightrainshowers_day = "lightrainshowers_day",
    Lightrainshowers_night = "lightrainshowers_night",
    Lightrainshowers_polartwilight = "lightrainshowers_polartwilight",
    Heavysleetshowers_day = "heavysleetshowers_day",
    Heavysleetshowers_night = "heavysleetshowers_night",
    Heavysleetshowers_polartwilight = "heavysleetshowers_polartwilight",
    Lightsleetshowers_day = "lightsleetshowers_day",
    Lightsleetshowers_night = "lightsleetshowers_night",
    Lightsleetshowers_polartwilight = "lightsleetshowers_polartwilight",
    Snow = "snow",
    Heavyrainshowersandthunder_day = "heavyrainshowersandthunder_day",
    Heavyrainshowersandthunder_night = "heavyrainshowersandthunder_night",
    Heavyrainshowersandthunder_polartwilight = "heavyrainshowersandthunder_polartwilight",
    Snowshowers_day = "snowshowers_day",
    Snowshowers_night = "snowshowers_night",
    Snowshowers_polartwilight = "snowshowers_polartwilight",
    Fog = "fog",
    Snowshowersandthunder_day = "snowshowersandthunder_day",
    Snowshowersandthunder_night = "snowshowersandthunder_night",
    Snowshowersandthunder_polartwilight = "snowshowersandthunder_polartwilight",
    Lightsnowandthunder = "lightsnowandthunder",
    Heavysleetandthunder = "heavysleetandthunder",
    Lightrain = "lightrain",
    Rainshowersandthunder_day = "rainshowersandthunder_day",
    Rainshowersandthunder_night = "rainshowersandthunder_night",
    Rainshowersandthunder_polartwilight = "rainshowersandthunder_polartwilight",
    Rain = "rain",
    Lightsnow = "lightsnow",
    Lightrainshowersandthunder_day = "lightrainshowersandthunder_day",
    Lightrainshowersandthunder_night = "lightrainshowersandthunder_night",
    Lightrainshowersandthunder_polartwilight = "lightrainshowersandthunder_polartwilight",
    Heavysleet = "heavysleet",
    Sleetandthunder = "sleetandthunder",
    Lightrainandthunder = "lightrainandthunder",
    Sleet = "sleet",
    Lightssleetshowersandthunder_day = "lightssleetshowersandthunder_day",
    Lightssleetshowersandthunder_night = "lightssleetshowersandthunder_night",
    Lightssleetshowersandthunder_polartwilight = "lightssleetshowersandthunder_polartwilight",
    Lightsleetandthunder = "lightsleetandthunder",
    Partlycloudy_day = "partlycloudy_day",
    Partlycloudy_night = "partlycloudy_night",
    Partlycloudy_polartwilight = "partlycloudy_polartwilight",
    Sleetshowersandthunder_day = "sleetshowersandthunder_day",
    Sleetshowersandthunder_night = "sleetshowersandthunder_night",
    Sleetshowersandthunder_polartwilight = "sleetshowersandthunder_polartwilight",
    Rainshowers_day = "rainshowers_day",
    Rainshowers_night = "rainshowers_night",
    Rainshowers_polartwilight = "rainshowers_polartwilight",
    Snowandthunder = "snowandthunder",
    Sleetshowers_day = "sleetshowers_day",
    Sleetshowers_night = "sleetshowers_night",
    Sleetshowers_polartwilight = "sleetshowers_polartwilight",
    Cloudy = "cloudy",
    Heavysnowshowersandthunder_day = "heavysnowshowersandthunder_day",
    Heavysnowshowersandthunder_night = "heavysnowshowersandthunder_night",
    Heavysnowshowersandthunder_polartwilight = "heavysnowshowersandthunder_polartwilight",
    Heavysnowshowers_day = "heavysnowshowers_day",
    Heavysnowshowers_night = "heavysnowshowers_night",
    Heavysnowshowers_polartwilight = "heavysnowshowers_polartwilight",
}

/** format code (file extension) */
export enum Format {
    Xml = "xml",
}

/** format code (file extension) */
export enum Format2 {
    Json = "json",
}

/** format code (file extension) */
export enum Format3 {
    Json = "json",
}

/** format code (file extension) */
export enum Format4 {
    Json = "json",
}

export class Meta implements IMeta {
    units!: ForecastUnits;
    /** Update time for this forecast */
    updated_at!: string;

    constructor(data?: IMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.units = new ForecastUnits();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.units = _data["units"] ? ForecastUnits.fromJS(_data["units"]) : new ForecastUnits();
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Meta {
        data = typeof data === 'object' ? data : {};
        let result = new Meta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["units"] = this.units ? this.units.toJSON() : <any>undefined;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IMeta {
    units: ForecastUnits;
    /** Update time for this forecast */
    updated_at: string;
}

export class Data implements IData {
    /** Parameters which applies to this exact point in time */
    instant!: Instant;
    /** Parameters with validity times over twelve hours. Will not exist for all time steps. */
    next_12_hours?: Next_12_hours | undefined;
    /** Parameters with validity times over one hour. Will not exist for all time steps. */
    next_1_hours?: Next_1_hours | undefined;
    /** Parameters with validity times over six hours. Will not exist for all time steps. */
    next_6_hours?: Next_6_hours | undefined;

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.instant = new Instant();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.instant = _data["instant"] ? Instant.fromJS(_data["instant"]) : new Instant();
            this.next_12_hours = _data["next_12_hours"] ? Next_12_hours.fromJS(_data["next_12_hours"]) : <any>undefined;
            this.next_1_hours = _data["next_1_hours"] ? Next_1_hours.fromJS(_data["next_1_hours"]) : <any>undefined;
            this.next_6_hours = _data["next_6_hours"] ? Next_6_hours.fromJS(_data["next_6_hours"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instant"] = this.instant ? this.instant.toJSON() : <any>undefined;
        data["next_12_hours"] = this.next_12_hours ? this.next_12_hours.toJSON() : <any>undefined;
        data["next_1_hours"] = this.next_1_hours ? this.next_1_hours.toJSON() : <any>undefined;
        data["next_6_hours"] = this.next_6_hours ? this.next_6_hours.toJSON() : <any>undefined;
        return data;
    }
}

export interface IData {
    /** Parameters which applies to this exact point in time */
    instant: Instant;
    /** Parameters with validity times over twelve hours. Will not exist for all time steps. */
    next_12_hours?: Next_12_hours | undefined;
    /** Parameters with validity times over one hour. Will not exist for all time steps. */
    next_1_hours?: Next_1_hours | undefined;
    /** Parameters with validity times over six hours. Will not exist for all time steps. */
    next_6_hours?: Next_6_hours | undefined;
}

export enum METJSONForecastType {
    Feature = "Feature",
}

export enum PointGeometryType {
    Point = "Point",
}

export class Instant implements IInstant {
    details?: ForecastTimeInstant | undefined;

    constructor(data?: IInstant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ForecastTimeInstant.fromJS(_data["details"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Instant {
        data = typeof data === 'object' ? data : {};
        let result = new Instant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInstant {
    details?: ForecastTimeInstant | undefined;
}

export class Next_12_hours implements INext_12_hours {
    details!: ForecastTimePeriod;
    summary!: ForecastSummary;

    constructor(data?: INext_12_hours) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new ForecastTimePeriod();
            this.summary = new ForecastSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ForecastTimePeriod.fromJS(_data["details"]) : new ForecastTimePeriod();
            this.summary = _data["summary"] ? ForecastSummary.fromJS(_data["summary"]) : new ForecastSummary();
        }
    }

    static fromJS(data: any): Next_12_hours {
        data = typeof data === 'object' ? data : {};
        let result = new Next_12_hours();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface INext_12_hours {
    details: ForecastTimePeriod;
    summary: ForecastSummary;
}

export class Next_1_hours implements INext_1_hours {
    details!: ForecastTimePeriod;
    summary!: ForecastSummary;

    constructor(data?: INext_1_hours) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new ForecastTimePeriod();
            this.summary = new ForecastSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ForecastTimePeriod.fromJS(_data["details"]) : new ForecastTimePeriod();
            this.summary = _data["summary"] ? ForecastSummary.fromJS(_data["summary"]) : new ForecastSummary();
        }
    }

    static fromJS(data: any): Next_1_hours {
        data = typeof data === 'object' ? data : {};
        let result = new Next_1_hours();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface INext_1_hours {
    details: ForecastTimePeriod;
    summary: ForecastSummary;
}

export class Next_6_hours implements INext_6_hours {
    details!: ForecastTimePeriod;
    summary!: ForecastSummary;

    constructor(data?: INext_6_hours) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new ForecastTimePeriod();
            this.summary = new ForecastSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? ForecastTimePeriod.fromJS(_data["details"]) : new ForecastTimePeriod();
            this.summary = _data["summary"] ? ForecastSummary.fromJS(_data["summary"]) : new ForecastSummary();
        }
    }

    static fromJS(data: any): Next_6_hours {
        data = typeof data === 'object' ? data : {};
        let result = new Next_6_hours();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface INext_6_hours {
    details: ForecastTimePeriod;
    summary: ForecastSummary;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}